import numpy as npimport cv2import randomclass Input_generator:    def __init__(self,file_path,num_classes,shuffle=False,input_size=(224,224)):        self.shuffle = shuffle        self.num_classes=num_classes        self.input_size = input_size        self.file_path = file_path        self.pointer = 0        self.read_class_list(file_path)        if self.shuffle:            self.shuffle_data()    def read_class_list(self, file_txt):        with open(file_txt) as f:            lines = f.readlines()  #readlines()读取整个文件，并返回列表，一行为一个元素            self.images = []            self.labels = []            for i in lines:                items = i.split()  #split()的时候，多个空格当成一个空格；split(' ')的时候，多个空格都要分割，每个空格分割出来空。                self.images.append(items[0])                self.labels.append(int(items[1]))            self.data_size = len(self.labels)          #data_size表示总共有多少个数据    def shuffle_data(self):                   #打乱        images = self.images        labels = self.labels        self.images = []        self.labels = []        idx = np.random.permutation(len(labels)) #np.random.permutation()随机排列系列        for i in idx:            self.images.append(images[i])            self.labels.append(labels[i])    def reset_pointer(self):        self.pointer = 0        if self.shuffle:            self.shuffle_data()    def center_crop(self,image, crop_size):        h, w, _ = image.shape        top = (h - crop_size[0]) // 2        left = (w - crop_size[1]) // 2        bottom = top + crop_size[0]        right = left + crop_size[1]        image = image[top:bottom, left:right, :]        return image    def random_crop(self,image, crop_size):        h, w, _ = image.shape        crop = random.choice([[0, 0], [0, 12], [12, 0], [12, 12], [6, 6]])        top = crop[0]        left = crop[1]        bottom = top + crop_size[0]        right = left + crop_size[1]        image = image[top:bottom, left:right, :]        index = np.random.randint(0, 2)        if index == 1:            image = cv2.flip(image, 1)        return image    def next_batch(self, batch_size,aug_data=False):        paths = self.images[self.pointer:self.pointer + batch_size]        labels = self.labels[self.pointer:self.pointer + batch_size]        self.pointer += batch_size        images = np.ndarray([batch_size, self.input_size[0], self.input_size[1], 3])        for i in range(len(paths)):            img = cv2.imread(paths[i])            img = cv2.resize(img,(236,236))            if img is None:                raise RuntimeError('can not read image file {}'.format(paths[i]))            if aug_data:                img = self.random_crop(img,(224,224))            else:                img=self.center_crop(img,(224,224))            img = img.astype(np.float32)            mean, stev = cv2.meanStdDev(img)            # img = (img - mean[0][0]) / stev[0][0]            img[:, :, 0] = (img[:, :, 0] - mean[0][0]) / stev[0][0]            img[:, :, 1] = (img[:, :, 1] - mean[1][0]) / stev[1][0]            img[:, :, 2] = (img[:, :, 2] - mean[2][0]) / stev[2][0]            images[i] = img        one_hot_labels = np.zeros((batch_size, self.num_classes))        for i in range(len(labels)):            one_hot_labels[i][labels[i]] = 1.        labels=np.array(labels)        return images,one_hot_labels,labels    def batch_input(self,batch_size,aug_data,num_threads = 4):        enqueue_ops = []