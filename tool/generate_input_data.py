import numpy as npimport cv2import randomimport mathclass Input_generator:    def __init__(self,file_path,num_classes,shuffle=False,input_size=(224,224),ifscale = False):        self.shuffle = shuffle        self.num_classes=num_classes        self.input_size = input_size        self.file_path = file_path        self.pointer = 0        self.ifscale = ifscale        self.read_class_list(file_path)        if self.shuffle:            self.shuffle_data()    def read_class_list(self, file_txt):        with open(file_txt) as f:            lines = f.readlines()  #readlines()读取整个文件，并返回列表，一行为一个元素            self.images = []            self.labels = []            for i in lines:                items = i.split()  #split()的时候，多个空格当成一个空格；split(' ')的时候，多个空格都要分割，每个空格分割出来空。                self.images.append(items[0])                self.labels.append(int(items[1]))            self.data_size = len(self.labels)          #data_size表示总共有多少个数据    def rotate_image(self,image, angle, scale=1.0):        (h, w) = image.shape[:2]        center = (w // 2, h // 2)        M = cv2.getRotationMatrix2D(center, angle, scale)        rotated = cv2.warpAffine(image, M, (w, h))        return rotated    def shuffle_data(self):                   #打乱        images = self.images        labels = self.labels        self.images = []        self.labels = []        idx = np.random.permutation(len(labels)) #np.random.permutation()随机排列系列        for i in idx:            self.images.append(images[i])            self.labels.append(labels[i])    def reset_pointer(self):        self.pointer = 0        if self.shuffle:            self.shuffle_data()    def center_crop(self,image, crop_size):        h, w, _ = image.shape        top = (h - crop_size[0]) // 2        left = (w - crop_size[1]) // 2        bottom = top + crop_size[0]        right = left + crop_size[1]        image = image[top:bottom, left:right, :]        return image    def random_crop(self,image, crop_size,ifscale):        h, w, _ = image.shape        crop = random.choice([[0, 0], [0, 12], [12, 0], [12, 12], [6, 6]])        top = crop[0]        left = crop[1]        bottom = top + crop_size[0]        right = left + crop_size[1]        image = image[top:bottom, left:right, :]        if ifscale:            index = np.random.randint(0, 5)            if index == 0:                image = self.scale(image,0.8)            if index == 1:                image = self.scale(image,0.9)            if index == 2:                image = self.scale(image,1)            if index == 3:                image = self.scale(image,1.1)            if index == 4:                image = self.scale(image,1.2)        index = np.random.randint(0, 2)        if index == 1:            image = cv2.flip(image, 1)        return image    def scale(self,image,scale):        h, w, _ = image.shape        nh = math.ceil(h*scale)        nw = math.ceil(h*scale)        image = cv2.resize(image,(nh,nw))        if scale > 1:            top = int((h*(scale-1))/2)            bottom =int((h*scale)-top)            left = int((w*(scale-1))/2)            right = int((w*scale)-left)            image = image[top:bottom,left:right]        if scale == 1:            image = image        if scale < 1:            fill_size =int((h*(1-scale))/2)            image =cv2.copyMakeBorder(image,fill_size,fill_size,fill_size,fill_size,cv2.BORDER_CONSTANT)        return image    def next_batch(self, batch_size,aug_data=False):        paths = self.images[self.pointer:self.pointer + batch_size]        labels = self.labels[self.pointer:self.pointer + batch_size]        self.pointer += batch_size        images = np.ndarray([batch_size, self.input_size[0], self.input_size[1], 3])        for i in range(len(paths)):            img = cv2.imread(paths[i])            # img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)            # img = cv2.equalizeHist(img)            # img = cv2.merge([img,img,img])            img =cv2.cvtColor(img, cv2.COLOR_BGR2RGB)            img = cv2.resize(img,(236,236))            if img is None:                raise RuntimeError('can not read image file {}'.format(paths[i]))            if aug_data:                img = self.random_crop(img,(224,224),self.ifscale)            else:                img=self.center_crop(img,(224,224))            img = img.astype(np.float32)            mean, stev = cv2.meanStdDev(img)            if (stev[0][0]==0):                print(paths[i])            img[:, :, 0] = (img[:, :, 0] - mean[0][0]) / stev[0][0]            img[:, :, 1] = (img[:, :, 1] - mean[1][0]) / stev[1][0]            img[:, :, 2] = (img[:, :, 2] - mean[2][0]) / stev[2][0]            images[i] = img        one_hot_labels = np.zeros((batch_size, self.num_classes))        for i in range(len(labels)):            one_hot_labels[i][labels[i]] = 1.        labels=np.array(labels)        return images,one_hot_labels,labels